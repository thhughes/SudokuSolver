from Sudoku import Sudoku
from PriorityQueue import *
from Sudoku import Node

#This function returns the
def heuristic1(current_node, next_node):
    return next_node.getPossible()

def heuristic2(current_node, next_node):
    return next_node.getImpossible()


def A_Star(heuristic, world):
    graph = Sudoku(world)
    print graph

    start = []
    # sx,sy = graph._start_
    # gx,gy = graph._goal_
    # start = Node(sx,sy,o='N',c=1)
    # start._b = False
    # goal_l = []
    # goal_l.append(Node(gx,gy,o='N',c=1))
    # goal_l.append(Node(gx,gy,o='S',c=1))
    # goal_l.append(Node(gx,gy,o='E',c=1))
    # goal_l.append(Node(gx,gy,o='W',c=1))

    # for goal in goal_l:
    #     goal._b = False
    # Source:
    # Sample code from http://www.redblobgames.com/pathfinding/
    # Copyright 2014 Red Blob Games <redblobgames@gmail.com>
    frontier = PriorityQueue()
    frontier.put(start, 0)
    came_from = {}
    cost_so_far = {}
    moves = {}
    came_from[start] = None
    cost_so_far[start] = 0
    finished = False;

    examined_nodes = 0
    branching_factor = 0
    st = time.clock()
    while not frontier.empty():
        current = frontier.get()

        for goal in goal_l:
            cx,cy = current.get_loc()
            gx,gy = goal.get_loc()
            if cx == gx and cy == gy:
                finished = True
        if finished:
            break

        to_examine = []
        to_examine.extend(graph.actions(current))
        examined_nodes = examined_nodes + 1
        for next in to_examine:
            new_cost = cost_so_far[current] + next.cost()

            put_in_queue = (next not in cost_so_far) or (new_cost < cost_so_far[next])
            if put_in_queue:
                next.tot(new_cost)
                cost_so_far[next] = new_cost
                priority = new_cost + heuristic(next,goal)
                frontier.put(next,priority)
                came_from[next] = current
                moves[next] = current.move()
            else:
                branching_factor = branching_factor + 1


    et = time.clock()
    # print ("Elapsed time is: ",et-st)
    b = []
    movz = []
    n = current
    b.append(n)
    movz.append(n.move())

    print ("Your Score is: ", 100 - current._l)

    while(n != start):
        n = came_from[n]
        b.append(n)
        movz.append(n.move())

    b = b[::-1] #reverse a list
    movz = movz[::-1]
    print "Your path was: "
    print b
    print "You took a total of ", len(movz) - 1, "moves"
    print "You took these moves: "
    print "START"
    for m in movz:
        if m is None:
            pass
        else:
            print m
    print "DONE"

    print "Branching Factor: " , branching_factor
    print "Expanded Nodes: ", examined_nodes